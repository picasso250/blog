计算的极限
==========

都是写 PHP 的，别客气，先给大家提个问题：

大家都知道，如果你写代码的时候不小心的话，可能会出现死循环的情况，比如：

```php
function do_n($n, $callback)
{
    while ($n) {
        $callback();
        $n--;
    }
}
do_n(-1);
// 悲剧的死循环了，永远都不会停止
```

那么能不能写这样一个 `will_forever()` 函数来检测这种情况呢？

```php
/**
 * 读取 PHP 函数的源码，判断在给定的参数下会不会陷入死循环
 * @param string $php_source_code_str 函数的源码，字符串
 * @param array $args 函数的参数
 * @return bool 会陷入死循环的返回 true ，不会陷入死循环的返回 false
 */
function will_forever($php_source_code_str, $args);
```

你大概会说，这个肯定可以做到。

但我要提醒你一句，这个问题没那么简单哦。假设你模拟运行这个代码，然后检测运行时间。但问题在于，这个函数即使是300年没返回，也不一定是死循环，可能只是比较慢。也许第301年就返回了呢。

所以，模拟运行大概是行不通的。不过，或许有什么精妙的算法，进行了很多复杂的逻辑判断。最后推算出这个程序是否会陷入死循环。但这个算法很复杂，以至于你想不出来。不过，你也不敢断定这种精妙的算法不存在。

最先给这个题目一个答案的人，就是大名鼎鼎的 **图灵** 。如果程序猿们要供奉祖师爷，而且只能供奉一个，那肯定非图灵莫属了。

当然，那个时候，别说 PHP ，连电脑都没有。所以我用 PHP 给大家翻译一下图灵的回答。

图灵的回答是： **不行** 。再牛逼的程序员，都写不出来这个函数。

为了证明这一点，图灵假设有个姓牛名逼的程序员写出了这个函数，里面含有牛逼同学惊天地泣鬼神的算法结晶。但图灵写了一个十行代码的函数就打败了牛逼。就是下面这个函数 `anti_niubi()`

```php
function anti_niubi($code_str)
{
    if (will_forever($code_str, array($code_str))) {
        return;
    } else {
        while (true) {
            ;
        }
    }
}
```

我们来观察一下这个 `anti_niubi()` 函数。这个函数会调用 `will_forever()` 函数，如果 `will_forever()` 返回 `true` ，则立刻返回。如果 `will_forever()` 返回 `false` ，则会故意陷入一个死循环。

显然，这个死循环肯定有其妙用。但这一招到底是如何发挥的呢。我们看看图灵接下来的做法。然后图灵这样调用了这个函数

```php
// 将自身的定义源码当作参数调用
anti_niubi('
function anti_niubi($code_str)
{
    if (will_forever($code_str, array($code_str))) {
        return;
    } else {
        while (true) {
            ;
        }
    }
}
');
```

我们分析一下，图灵是如何打败牛逼的。当图灵将自身的定义源码当作参数调用这个 `anti_niubi()` 函数时， `anti_niubi()` 将会调用 `will_forever($code_str, array($code_str))` 。如果你足够敏感的话，你会意识到，这句话的意思是问 `will_forever()` 函数： `anti_niubi()` 函数对自身调用会不会死循环。如果 `will_forever()` 的回答是“会”，则我们立刻返回。如果 `will_forever()` 的回答是“不会”，则我们偏要进行死循环。也就是说， `will_forever()` 无论怎么说，都是错的。于是我们就有了第一个 `will_forever()` 函数不能预测的函数。 `will_forever()` 的神话就被打败了。

这个证明的妙处在于，不管你写出来的是什么玄妙的函数，他只要一招就可以立于不败之地。这就是反证法的神奇之处。

不光 PHP 写不出这个函数，任何其他的语言，就算是汇编也一样写不出这个 `will_forever()` 函数。

图灵的牛逼之处，在于他指出了 **计算的极限在哪里** 。计算机是个很牛逼的物件，而程序猿们也经常自认为很牛逼。但是我们的祖师爷说了，你再牛逼，也有你做不到的事情。类似的不可计算的问题还有很多，以后有时间一一道来。而且最令人伤心的是，不可计算的问题远远多于可计算的问题。不过幸好，大部分不可计算的问题，用语言描述起来都很、非常、极其的困难。所以放心，只要是别人提得出的，其中大部分问题，我们程序猿还是可以解决的。
